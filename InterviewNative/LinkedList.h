#include "ListElement.h"

#include <stdlib.h>

template <typename T>
class LinkedList
{
public:
    LinkedList();

    // copy constructor and assignment operator would be generated by the compiler otherwise
    LinkedList(const LinkedList& other);
    LinkedList<T>& operator=(LinkedList tmp);

    void push_front(const T& value);
    T pop_front();
    int LinkedList<T>::size() const;

private:
    ListElement<T>* _head;
    int _size;
};


// IMPLEMENTATION

template <typename T>
LinkedList<T>::LinkedList()
    : _head(NULL), _size(0)
{
}

template <typename T>
LinkedList<T>::LinkedList(const LinkedList& other)
    : _head(NULL), _size(0)
{
    if (other.size() == 0)
        return;
    _size = 1;
    ListElement<T>* otherCurrent = other._head;
    ListElement<T>* current = new ListElement<T>(other._head->value());
    _head = current;
    while (otherCurrent->getNext() != NULL)
    {
        otherCurrent = otherCurrent->getNext();
        ListElement<T>* newElement = new ListElement<T>(otherCurrent->value());
        current->setNext(newElement);
        ++_size;
        current = current->getNext();
    }
}

template <typename T>
LinkedList<T>& LinkedList<T>::operator=(LinkedList tmp)
{
    std::swap(_head, tmp._head);
    std::swap(_size, tmp._size);
    return this*;
}

template <typename T>
void LinkedList<T>::push_front(const T& value)
{
    ListElement<T>* newElement = new ListElement<T>(value);
    newElement->setNext(_head);
    _head = newElement;
    ++_size;
}

template <typename T>
T LinkedList<T>::pop_front()
{
    T value = _head->value();
    ListElement<T>* deleteMe = _head;
    _head = _head->getNext();
    --_size;
    delete deleteMe;
    return value;
}

template <typename T>
int LinkedList<T>::size() const
{
    return _size;
}